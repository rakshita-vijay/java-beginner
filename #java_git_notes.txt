To connect GitHub and VSCodium and get the repository to edit:
-------------------------------------------------------------
cd ~/dev/rakshita/java-beginner
code .

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

To run the program:
------------------
javac ./HelloWorld.java && java HelloWorld
javac ./HelloWorld.java && java HelloWorld <argument, if in code>

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

"String[] args" needs to be given only once in the main function definition, but n number of arguments can be passed by the user into the program when calling

the passed arguments, when called by user (in System.out commands, etc.), are indexed from 0, so they should be called as args[0], args[1], etc, where args[n] specifies a whole string entered (until a space, which differentiates between the input values)

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

print: after every System.out command, the compiler does not go to a new line
println: after every System.out command, the compiler automatically goes to a new line
printf: has multiple arguments (works like in c), compiler does not go to a new line

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

all long int values shoud have L as a suffix
long - L
double - D
float - F

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

10.5 (for example) is a double by default in Java (NOT FLOAT)
double is more precise than float (16 vs. 8 decimal places shown)

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

+ is addition and concatenation

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

method / compile-time overloading: method overloading is a compile-time polymorphism in which many methods share the same name but have distinct arguments, signatures, and return types

RETURN TYPE      METHOD NAME      PARAMETER(S)      ERROR OR NOT
   same             same              same             error
   same           different           same            no error

   same             same           different          no error
   same           different        different          no error

 different          same              same             error
 different        different           same            no error

 different          same           different          no error
 different        different        different          no error

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

looping statements: if-else, for, while, do-while, switch

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

data types that can be used in switch-case: byte, short, int, char, String, enum

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

To get input from the user:
--------------------------
1) String <variable> = System.console().readLine("<input line, if required>");

2) Class instance creation expression:

   <className> <variable> = new <className>();
   <className> <variable> = new <className>(<argument 1>, <argument 2>);

   import java.util.Scanner;
   (or import java.util.*;)

   Scanner <variable> = new Scanner(System.in);
   Scanner <variable> = new Scanner(new File("nameOfFileOnFileSystem"));

   String <variable> = <variable>.nextline();

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

string: inspection, comparison, manipulation

        inspection: length, charAt, indexOf, lastIndexOf, isEmpty, isBlank
                    <...>.charAt(index): use for string, returns character
                    <...>[index]: use for array, returns character
                    <...>.indexOf(<char>): returns integer index

        comparison: contentEquals, equals, equalsIgnoreCase, contains, startsWith, endsWith, regionMatches
                    contentEquals, equals: returns boolean if string value = value of arguments passed; latter is only for strings
                    contains: returns boolean if string contains argument passed
                    regionMatches: returns boolean if sub-regions are matched

        manipulation: type 1 ~ clean-up: indent, strip, stripLeading, stripTrailing, trim, toLowerCase, toUpperCase
                                         strip: removes all leading and trailing white spaces
                                         trim: removes only one leading and one trailing white space, not all

                      type 2 ~ transformation: concat, join, repeat, replace, replaceAll, replaceFirst, substring, subSequence
                                               concat: string + text = string
                                               join: concats many elements with delimiter

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

character to string: String.valueOf(<char>)

// ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

String: defined as a variable;
        uses concat;
        when manipulated, should be assigned to a variable;
        creates new object, returns new reference;

StringBuilder class: defined as an object;
                     uses append;
                     when manipulated, does not need to be assigned to a variable
                     (value of object changed, behaves like a queue);
                     returns self-reference;

                     delete, deleteCharAt, insert, reverse, setLength
